// ==============================================================
// RTL generated by Vivado(TM) HLS - High-Level Synthesis from C, C++ and OpenCL
// Version: 2020.1
// Copyright (C) 1986-2020 Xilinx, Inc. All Rights Reserved.
// Input
// ===========================================================

`timescale 1 ns / 1 ps 

(* CORE_GENERATION_INFO="compute,hls_ip_2020_1,{HLS_INPUT_TYPE=cxx,HLS_INPUT_FLOAT=0,HLS_INPUT_FIXED=1,HLS_INPUT_PART=xc7z020-clg484-1,HLS_INPUT_CLOCK=7.000000,HLS_INPUT_ARCH=others,HLS_SYN_CLOCK=8.486687,HLS_SYN_LAT=-1,HLS_SYN_TPT=none,HLS_SYN_MEM=77,HLS_SYN_DSP=138,HLS_SYN_FF=14995,HLS_SYN_LUT=30709,HLS_VERSION=2020_1}" *)

module compute (
        ap_clk,                             // Input
        ap_rst_n,                           // Input
        m_axi_uop_port_AWVALID,             // Input
        m_axi_uop_port_AWREADY,             // Input
        m_axi_uop_port_AWADDR,              // Input
        m_axi_uop_port_AWID,                // Input
        m_axi_uop_port_AWLEN,               // Input
        m_axi_uop_port_AWSIZE,              // Input
        m_axi_uop_port_AWBURST,             // Input
        m_axi_uop_port_AWLOCK,              // Input
        m_axi_uop_port_AWCACHE,
        m_axi_uop_port_AWPROT,
        m_axi_uop_port_AWQOS,
        m_axi_uop_port_AWREGION,
        m_axi_uop_port_AWUSER,
        m_axi_uop_port_WVALID,
        m_axi_uop_port_WREADY,
        m_axi_uop_port_WDATA,
        m_axi_uop_port_WSTRB,
        m_axi_uop_port_WLAST,
        m_axi_uop_port_WID,
        m_axi_uop_port_WUSER,
        m_axi_uop_port_ARVALID,
        m_axi_uop_port_ARREADY,
        m_axi_uop_port_ARADDR,
        m_axi_uop_port_ARID,
        m_axi_uop_port_ARLEN,
        m_axi_uop_port_ARSIZE,
        m_axi_uop_port_ARBURST,
        m_axi_uop_port_ARLOCK,
        m_axi_uop_port_ARCACHE,
        m_axi_uop_port_ARPROT,
        m_axi_uop_port_ARQOS,
        m_axi_uop_port_ARREGION,
        m_axi_uop_port_ARUSER,
        m_axi_uop_port_RVALID,
        m_axi_uop_port_RREADY,
        m_axi_uop_port_RDATA,
        m_axi_uop_port_RLAST,
        m_axi_uop_port_RID,
        m_axi_uop_port_RUSER,
        m_axi_uop_port_RRESP,
        m_axi_uop_port_BVALID,
        m_axi_uop_port_BREADY,
        m_axi_uop_port_BRESP,
        m_axi_uop_port_BID,
        m_axi_uop_port_BUSER,
        m_axi_data_port_AWVALID,
        m_axi_data_port_AWREADY,
        m_axi_data_port_AWADDR,
        m_axi_data_port_AWID,
        m_axi_data_port_AWLEN,
        m_axi_data_port_AWSIZE,
        m_axi_data_port_AWBURST,
        m_axi_data_port_AWLOCK,
        m_axi_data_port_AWCACHE,
        m_axi_data_port_AWPROT,
        m_axi_data_port_AWQOS,
        m_axi_data_port_AWREGION,
        m_axi_data_port_AWUSER,
        m_axi_data_port_WVALID,
        m_axi_data_port_WREADY,
        m_axi_data_port_WDATA,
        m_axi_data_port_WSTRB,
        m_axi_data_port_WLAST,
        m_axi_data_port_WID,
        m_axi_data_port_WUSER,
        m_axi_data_port_ARVALID,
        m_axi_data_port_ARREADY,
        m_axi_data_port_ARADDR,
        m_axi_data_port_ARID,
        m_axi_data_port_ARLEN,
        m_axi_data_port_ARSIZE,
        m_axi_data_port_ARBURST,
        m_axi_data_port_ARLOCK,
        m_axi_data_port_ARCACHE,
        m_axi_data_port_ARPROT,
        m_axi_data_port_ARQOS,
        m_axi_data_port_ARREGION,
        m_axi_data_port_ARUSER,
        m_axi_data_port_RVALID,
        m_axi_data_port_RREADY,
        m_axi_data_port_RDATA,
        m_axi_data_port_RLAST,
        m_axi_data_port_RID,
        m_axi_data_port_RUSER,
        m_axi_data_port_RRESP,
        m_axi_data_port_BVALID,
        m_axi_data_port_BREADY,
        m_axi_data_port_BRESP,
        m_axi_data_port_BID,
        m_axi_data_port_BUSER,
        gemm_queue_V_V_TDATA,
        gemm_queue_V_V_TVALID,
        gemm_queue_V_V_TREADY,
        l2g_dep_queue_V_TDATA,
        l2g_dep_queue_V_TVALID,
        l2g_dep_queue_V_TREADY,
        s2g_dep_queue_V_TDATA,
        s2g_dep_queue_V_TVALID,
        s2g_dep_queue_V_TREADY,
        g2l_dep_queue_V_TDATA,
        g2l_dep_queue_V_TVALID,
        g2l_dep_queue_V_TREADY,
        g2s_dep_queue_V_TDATA,
        g2s_dep_queue_V_TVALID,
        g2s_dep_queue_V_TREADY,
        inp_mem_V_Addr_A,
        inp_mem_V_EN_A,
        inp_mem_V_WEN_A,
        inp_mem_V_Din_A,
        inp_mem_V_Dout_A,
        inp_mem_V_Clk_A,
        inp_mem_V_Rst_A,
        wgt_mem_0_V_Addr_A,
        wgt_mem_0_V_EN_A,
        wgt_mem_0_V_WEN_A,
        wgt_mem_0_V_Din_A,
        wgt_mem_0_V_Dout_A,
        wgt_mem_0_V_Clk_A,
        wgt_mem_0_V_Rst_A,
        wgt_mem_1_V_Addr_A,
        wgt_mem_1_V_EN_A,
        wgt_mem_1_V_WEN_A,
        wgt_mem_1_V_Din_A,
        wgt_mem_1_V_Dout_A,
        wgt_mem_1_V_Clk_A,
        wgt_mem_1_V_Rst_A,
        out_mem_V_Addr_A,
        out_mem_V_EN_A,
        out_mem_V_WEN_A,
        out_mem_V_Din_A,
        out_mem_V_Dout_A,
        out_mem_V_Clk_A,
        out_mem_V_Rst_A,
        s_axi_CONTROL_BUS_AWVALID,
        s_axi_CONTROL_BUS_AWREADY,
        s_axi_CONTROL_BUS_AWADDR,
        s_axi_CONTROL_BUS_WVALID,
        s_axi_CONTROL_BUS_WREADY,
        s_axi_CONTROL_BUS_WDATA,
        s_axi_CONTROL_BUS_WSTRB,
        s_axi_CONTROL_BUS_ARVALID,
        s_axi_CONTROL_BUS_ARREADY,
        s_axi_CONTROL_BUS_ARADDR,
        s_axi_CONTROL_BUS_RVALID,
        s_axi_CONTROL_BUS_RREADY,
        s_axi_CONTROL_BUS_RDATA,
        s_axi_CONTROL_BUS_RRESP,
        s_axi_CONTROL_BUS_BVALID,
        s_axi_CONTROL_BUS_BREADY,
        s_axi_CONTROL_BUS_BRESP,
        interrupt
);

parameter    C_S_AXI_CONTROL_BUS_DATA_WIDTH    = 32;
parameter    C_S_AXI_CONTROL_BUS_ADDR_WIDTH    = 6;
parameter    C_S_AXI_DATA_WIDTH                = 32;
parameter    C_M_AXI_UOP_PORT_ID_WIDTH         = 1;
parameter    C_M_AXI_UOP_PORT_ADDR_WIDTH       = 32;
parameter    C_M_AXI_UOP_PORT_DATA_WIDTH       = 32;
parameter    C_M_AXI_UOP_PORT_AWUSER_WIDTH     = 1;
parameter    C_M_AXI_UOP_PORT_ARUSER_WIDTH     = 1;
parameter    C_M_AXI_UOP_PORT_WUSER_WIDTH      = 1;
parameter    C_M_AXI_UOP_PORT_RUSER_WIDTH      = 1;
parameter    C_M_AXI_UOP_PORT_BUSER_WIDTH      = 1;
parameter    C_M_AXI_UOP_PORT_USER_VALUE       = 0;
parameter    C_M_AXI_UOP_PORT_PROT_VALUE       = 0;
parameter    C_M_AXI_UOP_PORT_CACHE_VALUE      = 3;
parameter    C_M_AXI_DATA_WIDTH                = 32;
parameter    C_M_AXI_DATA_PORT_ID_WIDTH        = 1;
parameter    C_M_AXI_DATA_PORT_ADDR_WIDTH      = 32;
parameter    C_M_AXI_DATA_PORT_DATA_WIDTH      = 64;
parameter    C_M_AXI_DATA_PORT_AWUSER_WIDTH    = 1;
parameter    C_M_AXI_DATA_PORT_ARUSER_WIDTH    = 1;
parameter    C_M_AXI_DATA_PORT_WUSER_WIDTH     = 1;
parameter    C_M_AXI_DATA_PORT_RUSER_WIDTH     = 1;
parameter    C_M_AXI_DATA_PORT_BUSER_WIDTH     = 1;
parameter    C_M_AXI_DATA_PORT_USER_VALUE      = 0;
parameter    C_M_AXI_DATA_PORT_PROT_VALUE      = 0;
parameter    C_M_AXI_DATA_PORT_CACHE_VALUE     = 3;

parameter    C_S_AXI_CONTROL_BUS_WSTRB_WIDTH   = (32 / 8);
parameter    C_S_AXI_WSTRB_WIDTH               = (32 / 8);
parameter    C_M_AXI_UOP_PORT_WSTRB_WIDTH      = (32 / 8);
parameter    C_M_AXI_WSTRB_WIDTH               = (32 / 8);
parameter    C_M_AXI_DATA_PORT_WSTRB_WIDTH     = (64 / 8);



input                                           ap_clk;                        // Input
input                                           ap_rst_n;                      // Input
output                                          m_axi_uop_port_AWVALID;        // Gen By compute_uop_port_m_axi_U
input                                           m_axi_uop_port_AWREADY;        // Input
output  [C_M_AXI_UOP_PORT_ADDR_WIDTH - 1:0]     m_axi_uop_port_AWADDR;         // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_ID_WIDTH - 1:0]       m_axi_uop_port_AWID;           // Gen By compute_uop_port_m_axi_U
output  [7:0]                                   m_axi_uop_port_AWLEN;          // Gen By compute_uop_port_m_axi_U
output  [2:0]                                   m_axi_uop_port_AWSIZE;         // Gen By compute_uop_port_m_axi_U
output  [1:0]                                   m_axi_uop_port_AWBURST;        // Gen By compute_uop_port_m_axi_U
output  [1:0]                                   m_axi_uop_port_AWLOCK;         // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_AWCACHE;        // Gen By compute_uop_port_m_axi_U
output  [2:0]                                   m_axi_uop_port_AWPROT;         // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_AWQOS;          // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_AWREGION;       // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_AWUSER_WIDTH - 1:0]   m_axi_uop_port_AWUSER;         // Gen By compute_uop_port_m_axi_U
output                                          m_axi_uop_port_WVALID;         // Gen By compute_uop_port_m_axi_U
input                                           m_axi_uop_port_WREADY;         // Input
output  [C_M_AXI_UOP_PORT_DATA_WIDTH - 1:0]     m_axi_uop_port_WDATA;          // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_WSTRB_WIDTH - 1:0]    m_axi_uop_port_WSTRB;          // Gen By compute_uop_port_m_axi_U
output                                          m_axi_uop_port_WLAST;          // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_ID_WIDTH - 1:0]       m_axi_uop_port_WID;            // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_WUSER_WIDTH - 1:0]    m_axi_uop_port_WUSER;          // Gen By compute_uop_port_m_axi_U
output                                          m_axi_uop_port_ARVALID;        // Gen By compute_uop_port_m_axi_U
input                                           m_axi_uop_port_ARREADY;        // Input
output  [C_M_AXI_UOP_PORT_ADDR_WIDTH - 1:0]     m_axi_uop_port_ARADDR;         // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_ID_WIDTH - 1:0]       m_axi_uop_port_ARID;           // Gen By compute_uop_port_m_axi_U
output  [7:0]                                   m_axi_uop_port_ARLEN;          // Gen By compute_uop_port_m_axi_U
output  [2:0]                                   m_axi_uop_port_ARSIZE;         // Gen By compute_uop_port_m_axi_U
output  [1:0]                                   m_axi_uop_port_ARBURST;        // Gen By compute_uop_port_m_axi_U
output  [1:0]                                   m_axi_uop_port_ARLOCK;         // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_ARCACHE;        // Gen By compute_uop_port_m_axi_U
output  [2:0]                                   m_axi_uop_port_ARPROT;         // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_ARQOS;          // Gen By compute_uop_port_m_axi_U
output  [3:0]                                   m_axi_uop_port_ARREGION;       // Gen By compute_uop_port_m_axi_U
output  [C_M_AXI_UOP_PORT_ARUSER_WIDTH - 1:0]   m_axi_uop_port_ARUSER;         // Gen By compute_uop_port_m_axi_U
input                                           m_axi_uop_port_RVALID;         // Input
output                                          m_axi_uop_port_RREADY;         // Gen By compute_uop_port_m_axi_U
input   [C_M_AXI_UOP_PORT_DATA_WIDTH - 1:0]     m_axi_uop_port_RDATA;          // Input
input                                           m_axi_uop_port_RLAST;          // Input
input   [C_M_AXI_UOP_PORT_ID_WIDTH - 1:0]       m_axi_uop_port_RID;            // Input
input   [C_M_AXI_UOP_PORT_RUSER_WIDTH - 1:0]    m_axi_uop_port_RUSER;          // Input
input   [1:0]                                   m_axi_uop_port_RRESP;          // Input
input                                           m_axi_uop_port_BVALID;         // Input
output                                          m_axi_uop_port_BREADY;         // Gen By compute_uop_port_m_axi_U
input   [1:0]                                   m_axi_uop_port_BRESP;          // Input
input   [C_M_AXI_UOP_PORT_ID_WIDTH - 1:0]       m_axi_uop_port_BID;            // Input
input   [C_M_AXI_UOP_PORT_BUSER_WIDTH - 1:0]    m_axi_uop_port_BUSER;          // Input

output                                          m_axi_data_port_AWVALID;       // Gen By compute_data_port_m_axi_U
input                                           m_axi_data_port_AWREADY;       // Input
output  [C_M_AXI_DATA_PORT_ADDR_WIDTH - 1:0]    m_axi_data_port_AWADDR;        // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_ID_WIDTH - 1:0]      m_axi_data_port_AWID;          // Gen By compute_data_port_m_axi_U
output  [7:0]                                   m_axi_data_port_AWLEN;         // Gen By compute_data_port_m_axi_U
output  [2:0]                                   m_axi_data_port_AWSIZE;        // Gen By compute_data_port_m_axi_U
output  [1:0]                                   m_axi_data_port_AWBURST;       // Gen By compute_data_port_m_axi_U
output  [1:0]                                   m_axi_data_port_AWLOCK;        // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_AWCACHE;       // Gen By compute_data_port_m_axi_U
output  [2:0]                                   m_axi_data_port_AWPROT;        // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_AWQOS;         // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_AWREGION;      // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_AWUSER_WIDTH - 1:0]  m_axi_data_port_AWUSER;        // Gen By compute_data_port_m_axi_U
output                                          m_axi_data_port_WVALID;        // Gen By compute_data_port_m_axi_U
input                                           m_axi_data_port_WREADY;        // Input
output  [C_M_AXI_DATA_PORT_DATA_WIDTH - 1:0]    m_axi_data_port_WDATA;         // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_WSTRB_WIDTH - 1:0]   m_axi_data_port_WSTRB;         // Gen By compute_data_port_m_axi_U
output                                          m_axi_data_port_WLAST;         // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_ID_WIDTH - 1:0]      m_axi_data_port_WID;           // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_WUSER_WIDTH - 1:0]   m_axi_data_port_WUSER;         // Gen By compute_data_port_m_axi_U
output                                          m_axi_data_port_ARVALID;       // Gen By compute_data_port_m_axi_U
input                                           m_axi_data_port_ARREADY;       // Input
output  [C_M_AXI_DATA_PORT_ADDR_WIDTH - 1:0]    m_axi_data_port_ARADDR;        // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_ID_WIDTH - 1:0]      m_axi_data_port_ARID;          // Gen By compute_data_port_m_axi_U
output  [7:0]                                   m_axi_data_port_ARLEN;         // Gen By compute_data_port_m_axi_U
output  [2:0]                                   m_axi_data_port_ARSIZE;        // Gen By compute_data_port_m_axi_U
output  [1:0]                                   m_axi_data_port_ARBURST;       // Gen By compute_data_port_m_axi_U
output  [1:0]                                   m_axi_data_port_ARLOCK;        // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_ARCACHE;       // Gen By compute_data_port_m_axi_U
output  [2:0]                                   m_axi_data_port_ARPROT;        // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_ARQOS;         // Gen By compute_data_port_m_axi_U
output  [3:0]                                   m_axi_data_port_ARREGION;      // Gen By compute_data_port_m_axi_U
output  [C_M_AXI_DATA_PORT_ARUSER_WIDTH - 1:0]  m_axi_data_port_ARUSER;        // Gen By compute_data_port_m_axi_U
input                                           m_axi_data_port_RVALID;        // Input
output                                          m_axi_data_port_RREADY;        // Gen By compute_data_port_m_axi_U
input   [C_M_AXI_DATA_PORT_DATA_WIDTH - 1:0]    m_axi_data_port_RDATA;         // Input
input                                           m_axi_data_port_RLAST;         // Input
input   [C_M_AXI_DATA_PORT_ID_WIDTH - 1:0]      m_axi_data_port_RID;           // Input
input   [C_M_AXI_DATA_PORT_RUSER_WIDTH - 1:0]   m_axi_data_port_RUSER;         // Input
input   [1:0]                                   m_axi_data_port_RRESP;         // Input
input                                           m_axi_data_port_BVALID;        // Input
output                                          m_axi_data_port_BREADY;        // Gen By compute_data_port_m_axi_U
input   [1:0]                                   m_axi_data_port_BRESP;         // Input
input   [C_M_AXI_DATA_PORT_ID_WIDTH - 1:0]      m_axi_data_port_BID;           // Input
input   [C_M_AXI_DATA_PORT_BUSER_WIDTH - 1:0]   m_axi_data_port_BUSER;         // Input

input   [127:0]                                 gemm_queue_V_V_TDATA;          // Input
input                                           gemm_queue_V_V_TVALID;         // Input
output                                          gemm_queue_V_V_TREADY;         // TODO

input   [7:0]                                   l2g_dep_queue_V_TDATA;         // Input
input                                           l2g_dep_queue_V_TVALID;        // Input
output                                          l2g_dep_queue_V_TREADY;        // TODO

input   [7:0]                                   s2g_dep_queue_V_TDATA;         // Input
input                                           s2g_dep_queue_V_TVALID;        // Input
output                                          s2g_dep_queue_V_TREADY;        // TODO

output  [7:0]                                   g2l_dep_queue_V_TDATA;         // Gen regslice_both_g2l_dep_queue_V_U
output                                          g2l_dep_queue_V_TVALID;        // TODO
input                                           g2l_dep_queue_V_TREADY;        // Input

output  [7:0]                                   g2s_dep_queue_V_TDATA;         // Gen By regslice_both_g2s_dep_queue_V_U
output                                          g2s_dep_queue_V_TVALID;        // TODO
input                                           g2s_dep_queue_V_TREADY;        // Input

output  [31:0]                                  inp_mem_V_Addr_A;              // TODO Gemm
output                                          inp_mem_V_EN_A;                // TODO Gemm
output  [15:0]                                  inp_mem_V_WEN_A;               // TODO = 0
output  [127:0]                                 inp_mem_V_Din_A;               // TODO = 0
input   [127:0]                                 inp_mem_V_Dout_A;              // Input 
output                                          inp_mem_V_Clk_A;               // TODO = ap_clk
output                                          inp_mem_V_Rst_A;               // TODO = ap_rst_n_inv

output  [31:0]                                  wgt_mem_0_V_Addr_A;            // TODO
output                                          wgt_mem_0_V_EN_A;              // TODO
output  [127:0]                                 wgt_mem_0_V_WEN_A;             // TODO = 0
output  [1023:0]                                wgt_mem_0_V_Din_A;             // TODO = 0
input   [1023:0]                                wgt_mem_0_V_Dout_A;            // Input
output                                          wgt_mem_0_V_Clk_A;             // TODO = ap_clk
output                                          wgt_mem_0_V_Rst_A;             // TODO = ap_rst_n_inv

output  [31:0]                                  wgt_mem_1_V_Addr_A;            // TODO
output                                          wgt_mem_1_V_EN_A;              // TODO
output  [127:0]                                 wgt_mem_1_V_WEN_A;             // TODO = 0
output  [1023:0]                                wgt_mem_1_V_Din_A;             // TODO = 0
input   [1023:0]                                wgt_mem_1_V_Dout_A;            // Input
output                                          wgt_mem_1_V_Clk_A;             // TODO = ap_clk
output                                          wgt_mem_1_V_Rst_A;             // TODO = ap_rst_n_inv

output  [31:0]                                  out_mem_V_Addr_A;              // TODO  Gemm Result / ALU Result
output                                          out_mem_V_EN_A;                // TODO  0/1
output  [15:0]                                  out_mem_V_WEN_A;               // TODO  16'd65535 / 16'd0
output  [127:0]                                 out_mem_V_Din_A;               // TODO  Gemm Result / ALU Result
input   [127:0]                                 out_mem_V_Dout_A;              // Input
output                                          out_mem_V_Clk_A;               // TODO = ap_clk
output                                          out_mem_V_Rst_A;               // TODO = ap_rst_n_inv

input                                           s_axi_CONTROL_BUS_AWVALID;     // Input
output                                          s_axi_CONTROL_BUS_AWREADY;     // Gen By compute_CONTROL_BUS_s_axi_U
input   [C_S_AXI_CONTROL_BUS_ADDR_WIDTH - 1:0]  s_axi_CONTROL_BUS_AWADDR;      // Input
input                                           s_axi_CONTROL_BUS_WVALID;      // Input
output                                          s_axi_CONTROL_BUS_WREADY;      // Gen By compute_CONTROL_BUS_s_axi_U
input   [C_S_AXI_CONTROL_BUS_DATA_WIDTH - 1:0]  s_axi_CONTROL_BUS_WDATA;       // Input
input   [C_S_AXI_CONTROL_BUS_WSTRB_WIDTH - 1:0] s_axi_CONTROL_BUS_WSTRB;       // Input
input                                           s_axi_CONTROL_BUS_ARVALID;     // Input
output                                          s_axi_CONTROL_BUS_ARREADY;     // Gen By compute_CONTROL_BUS_s_axi_U
input   [C_S_AXI_CONTROL_BUS_ADDR_WIDTH - 1:0]  s_axi_CONTROL_BUS_ARADDR;      // Input
output                                          s_axi_CONTROL_BUS_RVALID;      // Gen By compute_CONTROL_BUS_s_axi_U
input                                           s_axi_CONTROL_BUS_RREADY;      // Input
output  [C_S_AXI_CONTROL_BUS_DATA_WIDTH - 1:0]  s_axi_CONTROL_BUS_RDATA;       // Gen By compute_CONTROL_BUS_s_axi_U
output  [1:0]                                   s_axi_CONTROL_BUS_RRESP;       // Gen By compute_CONTROL_BUS_s_axi_U
output                                          s_axi_CONTROL_BUS_BVALID;      // Gen By compute_CONTROL_BUS_s_axi_U
input                                           s_axi_CONTROL_BUS_BREADY;      // Input
output  [1:0]                                   s_axi_CONTROL_BUS_BRESP;       // Gen By compute_CONTROL_BUS_s_axi_U
output                                          interrupt;                     // Gen By compute_CONTROL_BUS_s_axi_U

// ===========================================================
// Parameters
// ===========================================================
parameter    INSTRUCTION_WIDTH     = 128;

// state machine code
parameter state_idle_code          = 16'h0001;
parameter state_alu_start          = 16'h0002;
parameter state_alu_end            = 16'h0004;
parameter state_load_uop_start     = 16'h0008;
parameter state_load_uop_end       = 16'h0010;
parameter state_load_acc_start     = 16'h0020;
parameter state_load_acc_end       = 16'h0040;
parameter state_gemm_start         = 16'h0080;
parameter state_gemm_end           = 16'h0100;
parameter state_finish_start       = 16'h0200;
parameter state_finish_end         = 16'h0400;
parameter state_none               = 16'h0800;
parameter state_dep_write          = 16'h1000;
parameter state_end                = 16'h2000;

// ===========================================================
// Parameters END
// ===========================================================

reg            gemm_queue_V_V_TREADY;
reg            l2g_dep_queue_V_TREADY;
reg            s2g_dep_queue_V_TREADY;
reg            inp_mem_V_EN_A;
reg            wgt_mem_0_V_EN_A;
reg            wgt_mem_1_V_EN_A;
reg            out_mem_V_EN_A;
reg  [15:0]    out_mem_V_WEN_A;
reg  [127:0]   out_mem_V_Din_A;

wire           ap_rst_n_inv;
wire           gemm_queue_V_V_TREADY_int;

assign ap_rst_n_inv = ~ap_rst_n;

// ===========================================================
// Values
// ===========================================================
// Control Input
reg  [31:0] done_o;
reg         done_o_ap_vld;
reg         ap_ready;
reg         ap_done;
reg         ap_idle;
// Control Output
wire [31:0] done_i;
wire        ap_start;
wire [31:0] uops_V;
wire [31:0] biases_V;

// Read Uop Input
reg  [12:0] uop_mem_V_address0;
reg         uop_mem_V_ce0;
reg         uop_mem_V_we0;
reg  [31:0] uop_port_addr_read_reg_16568;

wire [31:0] uop_port_RDATA;

// Get instruction
wire                           regslice_both_gemm_queue_V_V_U_ack_in;
wire [INSTRUCTION_WIDTH - 1:0] gemm_queue_V_V_TDATA_int;                         // Instruction
wire                           gemm_queue_V_V_TVALID_int;
reg                            gemm_queue_V_V_TREADY_int;
wire                           regslice_both_gemm_queue_V_V_U_apdone_blk;

// instruction decode
wire [2:0]                     instruction_opcode;
wire                           instruction_l2g_dep_bit;
wire                           instruction_s2g_dep_bit;
wire                           instruction_g2l_dep_bit;
wire                           instruction_g2s_dep_bit;
// instruction decode load
wire [2:0]                     load_memop_id;
wire [15:0]                    load_sram_base_addr;
wire [31:0]                    load_dram_base_addr;
wire [15:0]                    load_y_size;
wire [15:0]                    load_x_size;
wire [15:0]                    load_x_stride;
wire [3:0]                     load_y_pad_top;
wire [3:0]                     load_y_pad_bottom;
wire [3:0]                     load_x_pad_left;
wire [3:0]                     load_x_pad_right;
// instruction decode gemm
wire                           gemm_reset;
wire [12:0]                    gemm_uop_begin;
wire [13:0]                    gemm_uop_end;
wire [13:0]                    gemm_iter_out;
wire [13:0]                    gemm_iter_in;
wire [10:0]                    gemm_dst_factor_out;
wire [10:0]                    gemm_dst_factor_in;
wire [10:0]                    gemm_src_factor_out;
wire [10:0]                    gemm_src_factor_in;
wire [9:0]                     gemm_wgt_factor_out;
wire [9:0]                     gemm_wgt_factor_in;
// instruction decode alu
wire                           alu_reset;
wire [12:0]                    alu_uop_begin;
wire [13:0]                    alu_uop_end;
wire [13:0]                    alu_iter_out;
wire [13:0]                    alu_iter_in;
wire [10:0]                    alu_dst_factor_out;
wire [10:0]                    alu_dst_factor_in;
wire [10:0]                    alu_src_factor_out;
wire [10:0]                    alu_src_factor_in;
wire [2:0]                     alu_sub_opcode;
wire                           alu_is_use_imm;
wire [15:0]                    alu_imm;
// instruction uop decode
wire                           is_load_opcode;
wire                           is_gemm_opcode;
wire                           is_finish_opcode;
wire                           is_alu_opcode;

// load instruction memid
wire                           is_uop_memid;
wire                           is_acc_memid;

// l2g queue
wire                           regslice_both_l2g_dep_queue_V_U_apdone_blk;
wire [7:0]                     l2g_dep_queue_V_TDATA_int;
wire                           l2g_dep_queue_V_TVALID_int;
reg                            l2g_dep_queue_V_TREADY_int;
wire                           regslice_both_l2g_dep_queue_V_U_ack_in;

// s2g queue
wire                           regslice_both_s2g_dep_queue_V_U_apdone_blk;
wire   [7:0]                   s2g_dep_queue_V_TDATA_int;
wire                           s2g_dep_queue_V_TVALID_int;
reg                            s2g_dep_queue_V_TREADY_int;
wire                           regslice_both_s2g_dep_queue_V_U_ack_in;

// load uop
reg  [31:0]  uop_port_addr_reg;
wire [31:0]  uop_dram_addr_offset;
wire [31:0]  uop_dram_addr;

// state machine
reg   [63:0] state_machine;
reg   [63:0] state_machine_temp;

wire         is_state_idle;
wire         is_state_alu_start;
wire         is_state_alu_end;
wire         is_state_load_uop_start;
wire         is_state_load_uop_end;
wire         is_state_load_acc_start;
wire         is_state_load_acc_end;
wire         is_state_gemm_start;
wire         is_state_gemm_end;
wire         is_state_finish_start;
wire         is_state_finish_end;
wire         is_state_none;
wire         is_dep_write;
wire         is_state_end;

// Input

// power-on initialization
initial
begin
    #0 state_machine = 64'd1;
end

// ===========================================================
// Get Instruction
// ===========================================================
// Read Compute Instruction
regslice_both #(                                               // Regsslice
    .DataWidth( INSTRUCTION_WIDTH ))
regslice_both_gemm_queue_V_V_U(
    .ap_clk(ap_clk),                                           // Input
    .ap_rst(ap_rst_n_inv),                                     // Input
    .data_in(gemm_queue_V_V_TDATA),                            // Input
    .vld_in(gemm_queue_V_V_TVALID),                            // Input
    .ack_in(regslice_both_gemm_queue_V_V_U_ack_in),            // Gen by Module
    .data_out(gemm_queue_V_V_TDATA_int),                       // Gen by Module
    .vld_out(gemm_queue_V_V_TVALID_int),                       // Gen by Module
    .ack_out(gemm_queue_V_V_TREADY_int),                       // TODO, 
    .apdone_blk(regslice_both_gemm_queue_V_V_U_apdone_blk)     // Gen by Module, no use
);

// gemm_queue_V_V_TREADY_int
always @ (*) begin
    if (   (ap_start == 1'b1)                                                         // start
         & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
         & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
         & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
         & (1'b1 == is_state_idle))                                                   // state idle
        begin
            gemm_queue_V_V_TREADY_int = 1'b1;
        end 
    else 
        begin
            gemm_queue_V_V_TREADY_int = 1'b0;
        end
end
// ===========================================================
// Get Instruction End
// ===========================================================

// ===========================================================
// Instruction Decode
// ===========================================================
assign instruction_opcode         = gemm_queue_V_V_TDATA_int[2:0];     // instruction opcode
assign instruction_l2g_dep_bit    = gemm_queue_V_V_TDATA_int[8'h3];    // instruction l2g depence bit
assign instruction_s2g_dep_bit    = gemm_queue_V_V_TDATA_int[8'h4];    // instruction s2g depence bit
assign instruction_g2l_dep_bit    = gemm_queue_V_V_TDATA_int[8'h5];    // #! Please Check
assign instruction_g2s_dep_bit    = gemm_queue_V_V_TDATA_int[8'h6];    // #! Please Check

// Load ACC/UOP
assign load_memop_id              = {{gemm_queue_V_V_TDATA_int[8:7]}};    // instruction memop id
assign load_sram_base_addr        = {{gemm_queue_V_V_TDATA_int[24:9]}};   // sram base
assign load_dram_base_addr        = {{gemm_queue_V_V_TDATA_int[56:25]}};  // dram base
assign load_y_size                = {{gemm_queue_V_V_TDATA_int[79:64]}};  // load y size
assign load_x_size                = {{gemm_queue_V_V_TDATA_int[95:80]}};  // load x size
assign load_x_stride              = {{gemm_queue_V_V_TDATA_int[111:96]}}; // load x stride
assign load_y_pad_top             = {{gemm_queue_V_V_TDATA_int[115:112]}};// load pad 2d # no use with 0
assign load_y_pad_bottom          = {{gemm_queue_V_V_TDATA_int[119:116]}};// load pad 2d # no use with 0
assign load_x_pad_left            = {{gemm_queue_V_V_TDATA_int[123:120]}};// load pad 2d # no use with 0
assign load_x_pad_right           = {{gemm_queue_V_V_TDATA_int[127:124]}};// load pad 2d # no use with 0

// GEMM
assign gemm_reset                 =   gemm_queue_V_V_TDATA_int[8'h7];     // GEMM reset bit
assign gemm_uop_begin             = {{gemm_queue_V_V_TDATA_int[20:8]}};   // GEMM uop begin
assign gemm_uop_end               = {{gemm_queue_V_V_TDATA_int[34:21]}};  // GEMM uop end
assign gemm_iter_out              = {{gemm_queue_V_V_TDATA_int[48:35]}};  // GEMM loop extent 0 end0
assign gemm_iter_in               = {{gemm_queue_V_V_TDATA_int[62:49]}};  // GEMM loop extent 1 end1
assign gemm_dst_factor_out        = {{gemm_queue_V_V_TDATA_int[74:64]}};  // GEMM accum index factor 0
assign gemm_dst_factor_in         = {{gemm_queue_V_V_TDATA_int[85:75]}};  // GEMM accum index factor 1
assign gemm_src_factor_out        = {{gemm_queue_V_V_TDATA_int[96:86]}};  // GEMM input index factor 0
assign gemm_src_factor_in         = {{gemm_queue_V_V_TDATA_int[107:97]}}; // GEMM input index factor 1
assign gemm_wgt_factor_out        = {{gemm_queue_V_V_TDATA_int[117:108]}};// GEMM wight index factor 0
assign gemm_wgt_factor_in         = {{gemm_queue_V_V_TDATA_int[127:118]}};// GEMM wight index factor 1

// ALU
assign alu_reset                  =   gemm_queue_V_V_TDATA_int[8'h7];     // ALU reset bit
assign alu_uop_begin              = {{gemm_queue_V_V_TDATA_int[20:8]}};   // ALU UOP begin
assign alu_uop_end                = {{gemm_queue_V_V_TDATA_int[34:21]}};  // ALU uop end
assign alu_iter_out               = {{gemm_queue_V_V_TDATA_int[48:35]}};  // ALU loop extent 0 end0
assign alu_iter_in                = {{gemm_queue_V_V_TDATA_int[62:49]}};  // ALU loop extent 1 end1
assign alu_dst_factor_out         = {{gemm_queue_V_V_TDATA_int[74:64]}};  // ALU accum index factor 0
assign alu_dst_factor_in          = {{gemm_queue_V_V_TDATA_int[85:75]}};  // ALU accum index factor 1
assign alu_src_factor_out         = {{gemm_queue_V_V_TDATA_int[96:86]}};  // ALU src index factor 0
assign alu_src_factor_in          = {{gemm_queue_V_V_TDATA_int[107:97]}}; // ALU src index factor 1
assign alu_sub_opcode             = {{gemm_queue_V_V_TDATA_int[110:108]}};// ALU sub opcode WIDTH=3
assign alu_is_use_imm             =   gemm_queue_V_V_TDATA_int[8'd111];   // ALU use imm bit
assign alu_imm                    = {{gemm_queue_V_V_TDATA_int[127:112]}};// ALU use imm bit

// opcode
assign is_load_opcode             = ((instruction_opcode == 3'd0) ? 1'b1 : 1'b0);
assign is_gemm_opcode             = ((instruction_opcode == 3'd2) ? 1'b1 : 1'b0);
assign is_finish_opcode           = ((instruction_opcode == 3'd3) ? 1'b1 : 1'b0);
assign is_alu_opcode              = ((instruction_opcode == 3'd4) ? 1'b1 : 1'b0);
assign is_uop_memid               = ((instruction_memop_id == 2'd0) ? 1'b1 : 1'b0);
assign is_acc_memid               = ((instruction_memop_id == 2'd3) ? 1'b1 : 1'b0);

// ===========================================================
// Instruction Decode END
// ===========================================================

// ===========================================================
// load 2 compute queue
// ===========================================================
regslice_both #(
    .DataWidth( 8 ))
regslice_both_l2g_dep_queue_V_U(
    .ap_clk(ap_clk),                                           // Input
    .ap_rst(ap_rst_n_inv),                                     // Input
    .data_in(l2g_dep_queue_V_TDATA),                           // Input
    .vld_in(l2g_dep_queue_V_TVALID),                           // Input
    .ack_in(regslice_both_l2g_dep_queue_V_U_ack_in),           // Gen By Module
    .data_out(l2g_dep_queue_V_TDATA_int),                      // Gen By Module
    .vld_out(l2g_dep_queue_V_TVALID_int),                      // Gen By Module
    .ack_out(l2g_dep_queue_V_TREADY_int),                      // TODO     
    .apdone_blk(regslice_both_l2g_dep_queue_V_U_apdone_blk)    // Gen By Module
);

// l2g_dep_queue_V_TREADY_int
always @ (*) begin
    if (  (ap_start == 1'b1) 
        & (gemm_queue_V_V_TVALID_int == 1'b1) |                                           // gemm queue valid
        & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0))      // s2g dependence satisfy or no dependence
        & (l2g_dep_queue_V_TVALID_int == 1'b1)                                            // l2g dependence satisfy
        & (instruction_l2g_dep_bit == 1'd1)                                               // l2g dependence
        & (1'b1 == is_state_idle))                                                        // status idle
        begin
            l2g_dep_queue_V_TREADY_int = 1'b1;
        end
    else
        begin
            l2g_dep_queue_V_TREADY_int = 1'b0;
        end
end

// ===========================================================
// store 2 compute queue
// ===========================================================
regslice_both #(
    .DataWidth( 8 ))
regslice_both_s2g_dep_queue_V_U(
    .ap_clk(ap_clk),                                           // Input
    .ap_rst(ap_rst_n_inv),                                     // Input
    .data_in(s2g_dep_queue_V_TDATA),                           // Input
    .vld_in(s2g_dep_queue_V_TVALID),                           // Input
    .ack_in(regslice_both_s2g_dep_queue_V_U_ack_in),           // Gen By Module
    .data_out(s2g_dep_queue_V_TDATA_int),                      // Gen By Module
    .vld_out(s2g_dep_queue_V_TVALID_int),                      // Gen By Module
    .ack_out(s2g_dep_queue_V_TREADY_int),                      // TODO 
    .apdone_blk(regslice_both_s2g_dep_queue_V_U_apdone_blk)    // Gen By Module
);
// s2g_dep_queue_V_TREADY_int
always @ (*) begin
    if (  (ap_start == 1'b1) 
        & (gemm_queue_V_V_TVALID_int == 1'b1) |                                           // gemm queue valid
        & (s2g_dep_queue_V_TVALID_int == 1'b1)                                            // s2g dependence satisfy 
        & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd1))      // l2g dependence satisfy or no dependence
        & (instruction_s2g_dep_bit == 1'd0)                                               // s2g dependence
        & (1'b1 == is_state_idle))                                                        // status idle
        begin
            s2g_dep_queue_V_TREADY_int = 1'b1;
        end 
    else 
        begins
            s2g_dep_queue_V_TREADY_int = 1'b0;
        end
end

// ===========================================================
// state machine
// ===========================================================

always @ (posedge ap_clk) begin
    if (ap_rst_n_inv == 1'b1) begin
        state_machine <= state_idle_code;
    end else begin
        state_machine <= state_machine_temp;
    end
end

assign is_state_idle           = state_machine[8'd0];
assign is_state_alu_start      = state_machine[8'd1];
assign is_state_alu_end        = state_machine[8'd2];
assign is_state_load_uop_start = state_machine[8'd3];
assign is_state_load_uop_end   = state_machine[8'd4];
assign is_state_load_acc_start = state_machine[8'd5];
assign is_state_load_acc_end   = state_machine[8'd6];
assign is_state_gemm_start     = state_machine[8'd7];
assign is_state_gemm_end       = state_machine[8'd8];
assign is_state_finish_start   = state_machine[8'd9];
assign is_state_finish_end     = state_machine[8'd10];
assign is_state_none           = state_machine[8'd11];
assign is_dep_write            = state_machine[8'd12];
assign is_state_end            = state_machine[8'd13];

always @ (*) begin
    case (state_machine)
        state_idle_code : begin
            // Load ACC
            if (  (ap_start == 1'b1)                                                         // start
                & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
                & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
                & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
                & (is_load_opcode == 1'd1)
                & (is_uop_memid == 1'd0)
                & (is_finish_opcode == 1'd0)
                & (1'b1 == is_state_idle))
                begin
                    state_machine_temp = state_load_acc_start;
                end

            // Load UOP
            else if ( (ap_start == 1'b1)                                                         // start
                    & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
                    & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
                    & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
                    & (is_uop_memid == 1'd1) 
                    & (is_load_opcode == 1'd1)
                    & (is_finish_opcode == 1'd0)
                    & (1'b1 == is_state_idle))
                begin
                    state_machine_temp = state_load_uop_start;
                end

            // None // Invalid Instruction && dependence satisty
            else if ( (ap_start == 1'b1)                                                         // start
                    & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
                    & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
                    & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
                    & (is_alu_opcode    == 1'd0) 
                    & (is_gemm_opcode   == 1'd0) 
                    & (is_load_opcode   == 1'd0) 
                    & (is_finish_opcode == 1'd0) 
                    & (1'b1 == is_state_idle))
                begin
                    state_machine_temp = state_none;
                end

            // ALU
            else if ( (ap_start == 1'b1)                                                         // start
                    & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
                    & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
                    & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
                    & (is_alu_opcode == 1'd1) 
                    & (is_gemm_opcode == 1'd0) 
                    & (is_load_opcode == 1'd0)
                    & (is_finish_opcode == 1'd0)
                    & (1'b1 == is_state_idle))
                begin
                    state_machine_temp = state_alu_start;
                end

            // GEMM
            else if ( (ap_start == 1'b1)                                                         // start
                    & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
                    & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
                    & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
                    & (is_gemm_opcode == 1'd1) 
                    & (is_load_opcode == 1'd0) 
                    & (is_finish_opcode == 1'd0) 
                    & (1'b1 == is_state_idle))) 
                begin
                    state_machine_temp = state_gemm_start;
                end 
            
            // Finish
            else if ((~((ap_start == 1'b0) | 
                        (gemm_queue_V_V_TVALID_int == 1'b0) | 
                        ((s2g_dep_queue_V_TVALID_int == 1'b0) & (tmp_6_fu_1679_p3 == 1'd1)) | 
                        ((l2g_dep_queue_V_TVALID_int == 1'b0) & (tmp_4_fu_1671_p3 == 1'd1))) 
                   & (is_finish_opcode == 1'd1) 
                   & (1'b1 == is_state_idle))) 
                begin
                    state_machine_temp = state_finish_start;
                end

            // Idle
            else
                begin
                    state_machine_temp = state_idle_code;
                end
        end

        state_none : begin
            state_machine_temp = state_idle_code;
        end

        default : begin
            state_machine_temp = 'bx;
        end
    endcase
end
// ===========================================================
// state machine end
// ===========================================================



// compute 2 load queue
regslice_both #(
    .DataWidth( 8 ))
regslice_both_g2l_dep_queue_V_U(
    .ap_clk(ap_clk),                                           // Input
    .ap_rst(ap_rst_n_inv),                                     // Input
    .data_in(8'd1),                                            // Input
    .vld_in(g2l_dep_queue_V_TVALID_int),                       // Input
    .ack_in(g2l_dep_queue_V_TREADY_int),                       // Gen By Module
    .data_out(g2l_dep_queue_V_TDATA),                          // Gen By Module
    .vld_out(regslice_both_g2l_dep_queue_V_U_vld_out),         // Gen By Module
    .ack_out(g2l_dep_queue_V_TREADY),                          // TODO
    .apdone_blk(regslice_both_g2l_dep_queue_V_U_apdone_blk)    // Gen By Module
);

// compute 2 store queue
regslice_both #(
    .DataWidth( 8 ))
regslice_both_g2s_dep_queue_V_U(
    .ap_clk(ap_clk),                                           // Input
    .ap_rst(ap_rst_n_inv),                                     // Input
    .data_in(8'd1),                                            // Input
    .vld_in(g2s_dep_queue_V_TVALID_int),                       // Input
    .ack_in(g2s_dep_queue_V_TREADY_int),                       // Gen By Module
    .data_out(g2s_dep_queue_V_TDATA),                          // Gen By Module
    .vld_out(regslice_both_g2s_dep_queue_V_U_vld_out),         // Gen By Module
    .ack_out(g2s_dep_queue_V_TREADY),                          // TODO
    .apdone_blk(regslice_both_g2s_dep_queue_V_U_apdone_blk)    // Gen By Module
);

// ===========================================================
// Compute Control
// ===========================================================
compute_CONTROL_BUS_s_axi #(
    .C_S_AXI_ADDR_WIDTH( C_S_AXI_CONTROL_BUS_ADDR_WIDTH ),
    .C_S_AXI_DATA_WIDTH( C_S_AXI_CONTROL_BUS_DATA_WIDTH ))
compute_CONTROL_BUS_s_axi_U(
    .AWVALID(s_axi_CONTROL_BUS_AWVALID),    // Input
    .AWREADY(s_axi_CONTROL_BUS_AWREADY),    // Output Gen by Module
    .AWADDR(s_axi_CONTROL_BUS_AWADDR),      // Input
    .WVALID(s_axi_CONTROL_BUS_WVALID),      // Input
    .WREADY(s_axi_CONTROL_BUS_WREADY),      // Input
    .WDATA(s_axi_CONTROL_BUS_WDATA),        // Input
    .WSTRB(s_axi_CONTROL_BUS_WSTRB),        // Input
    .ARVALID(s_axi_CONTROL_BUS_ARVALID),    // Input
    .ARREADY(s_axi_CONTROL_BUS_ARREADY),    // Output Gen By Module
    .ARADDR(s_axi_CONTROL_BUS_ARADDR),      // Input
    .RVALID(s_axi_CONTROL_BUS_RVALID),      // Output Gen By Module
    .RREADY(s_axi_CONTROL_BUS_RREADY),      // Input
    .RDATA(s_axi_CONTROL_BUS_RDATA),        // Output Gen By Module
    .RRESP(s_axi_CONTROL_BUS_RRESP),        // Output Gen By Module
    .BVALID(s_axi_CONTROL_BUS_BVALID),      // Output Gen By Module
    .BREADY(s_axi_CONTROL_BUS_BREADY),      // Input
    .BRESP(s_axi_CONTROL_BUS_BRESP),        // Output Gen by Moudle
    .ACLK(ap_clk),                          // Input
    .ARESET(ap_rst_n_inv),                  // Input
    .ACLK_EN(1'b1),                         // Input
    .done_o(done_o),                        // TODO
    .done_o_ap_vld(done_o_ap_vld),          // TODO
    .done_i(done_i),                        // Gen By Module # no use
    .ap_start(ap_start),                    // Gen by Module
    .interrupt(interrupt),                  // Output Gen by Module
    .ap_ready(ap_ready),                    // TODO 
    .ap_done(ap_done),                      // TODO
    .ap_idle(ap_idle),                      // TODO
    .uops_V(uops_V),                        // Gen by Module # Add to uop dram base addr
    .biases_V(biases_V)                     // Gen by Module # Add to acc dram base addr
);

// Wether Done ALL other state done
always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state62)) 
        begin
            done_o = 32'd1;
        end 
    
    else if (   (ap_start == 1'b1)                                                         // start
              & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
              & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
              & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
              & (1'b1 == is_state_idle))                                                   // state idle
        begin
            done_o = 32'd0;  // Only when state machine start
        end
    else 
        begin
            done_o = 'bx;
        end
end

// Done_o Valid signal
always @ (*) begin
    if ((1'b1 == ap_CS_fsm_state62)  |
        ((ap_start == 1'b1)                                                           // start
         & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
         & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
         & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
         & (1'b1 == is_state_idle)))
        begin
            done_o_ap_vld = 1'b1; // Only when state machine start
        end 
    else 
        begin
            done_o_ap_vld = 1'b0;
        end
end

// Ready Write g2l & g2s
always @ (*) begin
    if (  (1'b0 == ap_block_state64_io)
        &  (regslice_both_g2s_dep_queue_V_U_apdone_blk == 1'b0)
        &  (regslice_both_g2l_dep_queue_V_U_apdone_blk == 1'b0)
        &  (1'b1 == ap_CS_fsm_state64)) begin
        ap_ready = 1'b1;
    end else begin
        ap_ready = 1'b0;
    end
end
// Done Write g2l & g2s
always @ (*) begin
    if (   (1'b0 == ap_block_state64_io)
        &  (regslice_both_g2s_dep_queue_V_U_apdone_blk == 1'b0)
        &  (regslice_both_g2l_dep_queue_V_U_apdone_blk == 1'b0)
        &  (1'b1 == ap_CS_fsm_state64))  
        begin
            ap_done = 1'b1;
        end 
    else 
        begin
            ap_done = 1'b0;
        end
end

// Idle
always @ (*) begin
    if ((ap_start == 1'b0) & (1'b1 == is_state_idle))
        begin
            ap_idle = 1'b1;
        end 
    else 
        begin
            ap_idle = 1'b0;
        end
end
// ===========================================================
// Control End
// ===========================================================

// ===========================================================
// Load uop
// ===========================================================
// Load Uop to Uop Mem
compute_uop_port_m_axi #(
    .CONSERVATIVE( 0 ),
    .USER_DW( 32 ),
    .USER_AW( 32 ),
    .USER_MAXREQS( 5 ),
    .NUM_READ_OUTSTANDING( 16 ),
    .NUM_WRITE_OUTSTANDING( 16 ),
    .MAX_READ_BURST_LENGTH( 16 ),
    .MAX_WRITE_BURST_LENGTH( 16 ),
    .C_M_AXI_ID_WIDTH( C_M_AXI_UOP_PORT_ID_WIDTH ),
    .C_M_AXI_ADDR_WIDTH( C_M_AXI_UOP_PORT_ADDR_WIDTH ),
    .C_M_AXI_DATA_WIDTH( C_M_AXI_UOP_PORT_DATA_WIDTH ),
    .C_M_AXI_AWUSER_WIDTH( C_M_AXI_UOP_PORT_AWUSER_WIDTH ),
    .C_M_AXI_ARUSER_WIDTH( C_M_AXI_UOP_PORT_ARUSER_WIDTH ),
    .C_M_AXI_WUSER_WIDTH( C_M_AXI_UOP_PORT_WUSER_WIDTH ),
    .C_M_AXI_RUSER_WIDTH( C_M_AXI_UOP_PORT_RUSER_WIDTH ),
    .C_M_AXI_BUSER_WIDTH( C_M_AXI_UOP_PORT_BUSER_WIDTH ),
    .C_USER_VALUE( C_M_AXI_UOP_PORT_USER_VALUE ),
    .C_PROT_VALUE( C_M_AXI_UOP_PORT_PROT_VALUE ),
    .C_CACHE_VALUE( C_M_AXI_UOP_PORT_CACHE_VALUE ))
compute_uop_port_m_axi_U(
    .AWVALID(m_axi_uop_port_AWVALID),       // Output Gen By Module to compute module output
    .AWREADY(m_axi_uop_port_AWREADY),       // Input
    .AWADDR(m_axi_uop_port_AWADDR),         // Output Gen By Module to compute module output
    .AWID(m_axi_uop_port_AWID),             // Output Gen By Module to compute module output
    .AWLEN(m_axi_uop_port_AWLEN),           // Output Gen By Module to compute module output
    .AWSIZE(m_axi_uop_port_AWSIZE),         // Output Gen By Module to compute module output
    .AWBURST(m_axi_uop_port_AWBURST),       // Output Gen By Module to compute module output
    .AWLOCK(m_axi_uop_port_AWLOCK),         // Output Gen By Module to compute module output
    .AWCACHE(m_axi_uop_port_AWCACHE),       // Output Gen By Module to compute module output
    .AWPROT(m_axi_uop_port_AWPROT),         // Output Gen By Module to compute module output
    .AWQOS(m_axi_uop_port_AWQOS),           // Output Gen By Module to compute module output
    .AWREGION(m_axi_uop_port_AWREGION),     // Output Gen By Module to compute module output
    .AWUSER(m_axi_uop_port_AWUSER),         // Output Gen By Module to compute module output
    .WVALID(m_axi_uop_port_WVALID),         // Output Gen By Module to compute module output
    .WREADY(m_axi_uop_port_WREADY),         // Input
    .WDATA(m_axi_uop_port_WDATA),           // Output Gen By Module to compute module output
    .WSTRB(m_axi_uop_port_WSTRB),           // Output Gen By Module to compute module output
    .WLAST(m_axi_uop_port_WLAST),           // Output Gen By Module to compute module output
    .WID(m_axi_uop_port_WID),               // Output Gen By Module to compute module output
    .WUSER(m_axi_uop_port_WUSER),           // Output Gen By Module to compute module output
    .ARVALID(m_axi_uop_port_ARVALID),       // Output Gen By Module to compute module output
    .ARREADY(m_axi_uop_port_ARREADY),       // Input
    .ARADDR(m_axi_uop_port_ARADDR),         // Output Gen By Module to compute module output
    .ARID(m_axi_uop_port_ARID),             // Output Gen By Module to compute module output
    .ARLEN(m_axi_uop_port_ARLEN),           // Output Gen By Module to compute module output
    .ARSIZE(m_axi_uop_port_ARSIZE),         // Output Gen By Module to compute module output
    .ARBURST(m_axi_uop_port_ARBURST),       // Output Gen By Module to compute module output
    .ARLOCK(m_axi_uop_port_ARLOCK),         // Output Gen By Module to compute module output
    .ARCACHE(m_axi_uop_port_ARCACHE),       // Output Gen By Module to compute module output
    .ARPROT(m_axi_uop_port_ARPROT),         // Output Gen By Module to compute module output
    .ARQOS(m_axi_uop_port_ARQOS),           // Output Gen By Module to compute module output
    .ARREGION(m_axi_uop_port_ARREGION),     // Output Gen By Module to compute module output
    .ARUSER(m_axi_uop_port_ARUSER),         // Output Gen By Module to compute module output
    .RVALID(m_axi_uop_port_RVALID),         // Input
    .RREADY(m_axi_uop_port_RREADY),         // Output Gen By Module to compute module output
    .RDATA(m_axi_uop_port_RDATA),           // Input
    .RLAST(m_axi_uop_port_RLAST),           // Input
    .RID(m_axi_uop_port_RID),               // Input
    .RUSER(m_axi_uop_port_RUSER),           // Input
    .RRESP(m_axi_uop_port_RRESP),           // Input
    .BVALID(m_axi_uop_port_BVALID),         // Input
    .BREADY(m_axi_uop_port_BREADY),         // Output Gen By Module to compute module output
    .BRESP(m_axi_uop_port_BRESP),           // Input
    .BID(m_axi_uop_port_BID),               // Input
    .BUSER(m_axi_uop_port_BUSER),           // Input
    .ACLK(ap_clk),                          // Input
    .ARESET(ap_rst_n_inv),                  //  
    .ACLK_EN(1'b1),                         // 
    .I_ARVALID(uop_port_ARVALID),           // TODO
    .I_ARREADY(uop_port_ARREADY),           // Gen By Module #! Load UOP Ready Signed
    .I_ARADDR(uop_port_addr_reg),           // TODO, dram addr
    .I_ARID(1'd0),                          // Input
    .I_ARLEN(uop_port_ARLEN),               // TODO, x size for load
    .I_ARSIZE(3'd0),                        // Input
    .I_ARLOCK(2'd0),                        // Input
    .I_ARCACHE(4'd0),                       // Input
    .I_ARQOS(4'd0),                         // Input
    .I_ARPROT(3'd0),                        // Input
    .I_ARUSER(1'd0),                        // Input
    .I_ARBURST(2'd0),                       // Input
    .I_ARREGION(4'd0),                      // Input
    .I_RVALID(uop_port_RVALID),             // Gen By Module #! UOP Valid
    .I_RREADY(uop_port_RREADY),             // TODO
    .I_RDATA(uop_port_RDATA),               // Gen By Module #! to compute_uop_mem_V
    .I_RID(uop_port_RID),                   // Gen By Module # no use
    .I_RUSER(uop_port_RUSER),               // Gen By Module # no use
    .I_RRESP(uop_port_RRESP),               // Gen By Module # no use
    .I_RLAST(uop_port_RLAST),               // Gen By Module # no use
    .I_AWVALID(1'b0),                       // Input
    .I_AWREADY(uop_port_AWREADY),           // Gen By Module # no use
    .I_AWADDR(32'd0),                       // Input
    .I_AWID(1'd0),                          // Input
    .I_AWLEN(32'd0),                        // Input
    .I_AWSIZE(3'd0),                        // Input
    .I_AWLOCK(2'd0),                        // Input
    .I_AWCACHE(4'd0),                       // Input
    .I_AWQOS(4'd0),                         // Input
    .I_AWPROT(3'd0),                        // Input
    .I_AWUSER(1'd0),                        // Input
    .I_AWBURST(2'd0),                       // Input
    .I_AWREGION(4'd0),                      // Input
    .I_WVALID(1'b0),                        // Input
    .I_WREADY(uop_port_WREADY),             // Gen By Module # no use
    .I_WDATA(32'd0),                        // Input
    .I_WID(1'd0),                           // Input
    .I_WUSER(1'd0),                         // Input
    .I_WLAST(1'b0),                         // Input
    .I_WSTRB(4'd0),                         // Input
    .I_BVALID(uop_port_BVALID),             // Gen By Module # no use
    .I_BREADY(1'b0),                        // Input
    .I_BRESP(uop_port_BRESP),               // Gen By Module # no use
    .I_BID(uop_port_BID),                   // Gen By Module # no use
    .I_BUSER(uop_port_BUSER)                // Gen By Module # no use
);

assign uop_dram_addr_offset = {{uops_V[31:2]}};
assign uop_dram_addr        = (load_dram_base_addr + uop_dram_addr_offset);

// uop_port_ARVALID
always @ (*) begin
    if (((uop_port_ARREADY == 1'b1) & (1'b1 == is_state_load_uop_start))) begin
        uop_port_ARVALID = 1'b1;
    end else begin
        uop_port_ARVALID = 1'b0;
    end
end

// uop_port_addr_reg // same if with state machine 
always @ (posedge ap_clk) begin
    if ( (ap_start == 1'b1)                                                         // start
       & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
       & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
       & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
       & (is_uop_memid == 1'd1) 
       & (is_load_opcode == 1'd1)
       & (is_finish_opcode == 1'd0)
       & (1'b1 == is_state_idle))
    begin
        uop_port_addr_reg <= uop_dram_addr;
    end
end

assign uop_port_ARLEN = grp_fu_1337_p4; // TODO

// uop_port_RREADY // TODO
always @ (*) begin
    if (((icmp_ln480_reg_16554 == 1'd0) 
       & (1'b0 == ap_block_pp3_stage0_11001)
       & (ap_enable_reg_pp3_iter1 == 1'b1)
       & (1'b1 == ap_CS_fsm_pp3_stage0)))
        begin
            uop_port_RREADY = 1'b1;
        end
    else 
        begin
            uop_port_RREADY = 1'b0;
        end
end

// ===========================================================
// Load uop End
// ===========================================================

// Load Acc to Acc Memory
compute_data_port_m_axi #(
    .CONSERVATIVE( 0 ),
    .USER_DW( 64 ),
    .USER_AW( 32 ),
    .USER_MAXREQS( 5 ),
    .NUM_READ_OUTSTANDING( 16 ),
    .NUM_WRITE_OUTSTANDING( 16 ),
    .MAX_READ_BURST_LENGTH( 16 ),
    .MAX_WRITE_BURST_LENGTH( 16 ),
    .C_M_AXI_ID_WIDTH( C_M_AXI_DATA_PORT_ID_WIDTH ),
    .C_M_AXI_ADDR_WIDTH( C_M_AXI_DATA_PORT_ADDR_WIDTH ),
    .C_M_AXI_DATA_WIDTH( C_M_AXI_DATA_PORT_DATA_WIDTH ),
    .C_M_AXI_AWUSER_WIDTH( C_M_AXI_DATA_PORT_AWUSER_WIDTH ),
    .C_M_AXI_ARUSER_WIDTH( C_M_AXI_DATA_PORT_ARUSER_WIDTH ),
    .C_M_AXI_WUSER_WIDTH( C_M_AXI_DATA_PORT_WUSER_WIDTH ),
    .C_M_AXI_RUSER_WIDTH( C_M_AXI_DATA_PORT_RUSER_WIDTH ),
    .C_M_AXI_BUSER_WIDTH( C_M_AXI_DATA_PORT_BUSER_WIDTH ),
    .C_USER_VALUE( C_M_AXI_DATA_PORT_USER_VALUE ),
    .C_PROT_VALUE( C_M_AXI_DATA_PORT_PROT_VALUE ),
    .C_CACHE_VALUE( C_M_AXI_DATA_PORT_CACHE_VALUE ))
compute_data_port_m_axi_U(
    .AWVALID(m_axi_data_port_AWVALID),      // Output Gen By Module
    .AWREADY(m_axi_data_port_AWREADY),      // Input
    .AWADDR(m_axi_data_port_AWADDR),        // Output Gen By Module
    .AWID(m_axi_data_port_AWID),            // Output Gen By Module
    .AWLEN(m_axi_data_port_AWLEN),          // Output Gen By Module
    .AWSIZE(m_axi_data_port_AWSIZE),        // Output Gen By Module
    .AWBURST(m_axi_data_port_AWBURST),      // Output Gen By Module
    .AWLOCK(m_axi_data_port_AWLOCK),        // Output Gen By Module
    .AWCACHE(m_axi_data_port_AWCACHE),      // Output Gen By Module
    .AWPROT(m_axi_data_port_AWPROT),        // Output Gen By Module
    .AWQOS(m_axi_data_port_AWQOS),          // Output Gen By Module
    .AWREGION(m_axi_data_port_AWREGION),    // Output Gen By Module
    .AWUSER(m_axi_data_port_AWUSER),        // Output Gen By Module
    .WVALID(m_axi_data_port_WVALID),        // Output Gen By Module
    .WREADY(m_axi_data_port_WREADY),        // Input
    .WDATA(m_axi_data_port_WDATA),          // Output Gen By Module
    .WSTRB(m_axi_data_port_WSTRB),          // Output Gen By Module
    .WLAST(m_axi_data_port_WLAST),          // Output Gen By Module
    .WID(m_axi_data_port_WID),              // Output Gen By Module
    .WUSER(m_axi_data_port_WUSER),          // Output Gen By Module
    .ARVALID(m_axi_data_port_ARVALID),      // Output Gen By Module
    .ARREADY(m_axi_data_port_ARREADY),      // Input
    .ARADDR(m_axi_data_port_ARADDR),        // Output Gen By Module
    .ARID(m_axi_data_port_ARID),            // Output Gen By Module
    .ARLEN(m_axi_data_port_ARLEN),          // Output Gen By Module
    .ARSIZE(m_axi_data_port_ARSIZE),        // Output Gen By Module
    .ARBURST(m_axi_data_port_ARBURST),      // Output Gen By Module
    .ARLOCK(m_axi_data_port_ARLOCK),        // Output Gen By Module
    .ARCACHE(m_axi_data_port_ARCACHE),      // Output Gen By Module
    .ARPROT(m_axi_data_port_ARPROT),        // Output Gen By Module
    .ARQOS(m_axi_data_port_ARQOS),          // Output Gen By Module
    .ARREGION(m_axi_data_port_ARREGION),    // Output Gen By Module
    .ARUSER(m_axi_data_port_ARUSER),        // Output Gen By Module
    .RVALID(m_axi_data_port_RVALID),        // Input
    .RREADY(m_axi_data_port_RREADY),        // Output Gen By Module
    .RDATA(m_axi_data_port_RDATA),          // Input
    .RLAST(m_axi_data_port_RLAST),          // Input
    .RID(m_axi_data_port_RID),              // Input
    .RUSER(m_axi_data_port_RUSER),          // Input
    .RRESP(m_axi_data_port_RRESP),          // Input
    .BVALID(m_axi_data_port_BVALID),        // Input
    .BREADY(m_axi_data_port_BREADY),        // Output Gen By Module
    .BRESP(m_axi_data_port_BRESP),          // Input
    .BID(m_axi_data_port_BID),              // Input
    .BUSER(m_axi_data_port_BUSER),          // Input
    .ACLK(ap_clk),                          // Input
    .ARESET(ap_rst_n_inv),                  // Input
    .ACLK_EN(1'b1),                         // Input
    .I_ARVALID(data_port_ARVALID),          // TODO valid
    .I_ARREADY(data_port_ARREADY),          // Gen By Module
    .I_ARADDR(data_port_ARADDR),            // TODO, dram addr
    .I_ARID(1'd0),                          // Input
    .I_ARLEN(load_acc_x_size),              // TODO, x_size
    .I_ARSIZE(3'd0),                        // Input
    .I_ARLOCK(2'd0),                        // Input
    .I_ARCACHE(4'd0),                       // Input
    .I_ARQOS(4'd0),                         // Input
    .I_ARPROT(3'd0),                        // Input
    .I_ARUSER(1'd0),                        // Input
    .I_ARBURST(2'd0),                       // Input
    .I_ARREGION(4'd0),                      // Input
    .I_RVALID(data_port_RVALID),            // Gen By Module
    .I_RREADY(data_port_RREADY),            // TODO
    .I_RDATA(data_port_RDATA),              // Gen By Module // ACC data 64-bit
    .I_RID(data_port_RID),                  // Gen By Module # no use
    .I_RUSER(data_port_RUSER),              // Gen By Module # no use
    .I_RRESP(data_port_RRESP),              // Gen By Module # no use
    .I_RLAST(data_port_RLAST),              // Gen By Module # no use
    .I_AWVALID(1'b0),                       // Input
    .I_AWREADY(data_port_AWREADY),          // Gen By Module # no use
    .I_AWADDR(32'd0),                       // Input
    .I_AWID(1'd0),                          // Input
    .I_AWLEN(32'd0),                        // Input
    .I_AWSIZE(3'd0),                        // Input
    .I_AWLOCK(2'd0),                        // Input
    .I_AWCACHE(4'd0),                       // Input
    .I_AWQOS(4'd0),                         // Input
    .I_AWPROT(3'd0),                        // Input
    .I_AWUSER(1'd0),                        // Input
    .I_AWBURST(2'd0),                       // Input
    .I_AWREGION(4'd0),                      // Input
    .I_WVALID(1'b0),                        // Input
    .I_WREADY(data_port_WREADY),            // Gen By Module # no use
    .I_WDATA(64'd0),                        // Input
    .I_WID(1'd0),                           // Input
    .I_WUSER(1'd0),                         // Input
    .I_WLAST(1'b0),                         // Input
    .I_WSTRB(8'd0),                         // Input
    .I_BVALID(data_port_BVALID),            // Gen By Module # no use
    .I_BREADY(1'b0),                        // Input
    .I_BRESP(data_port_BRESP),              // Gen By Module # no use
    .I_BID(data_port_BID),                  // Gen By Module # no use
    .I_BUSER(data_port_BUSER)               // Gen By Module # no use
);

always @ (*) begin
    if (((data_port_ARREADY == 1'b1) & (1'b1 == ap_CS_fsm_state39))) begin
        data_port_ARVALID = 1'b1;
    end else begin
        data_port_ARVALID = 1'b0;
    end
end

assign data_port_ARADDR = zext_ln88_fu_11376_p1;

// load acc x-size
/*
 *load_acc_x_size =  16 * 32-bit * x_size / 64-bit
 */
always @ (posedge ap_clk) begin
    if (  (ap_start == 1'b1)                                                         // start
        & (gemm_queue_V_V_TVALID_int == 1'b1)                                        // gemm queue valid
        & ((s2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_s2g_dep_bit == 1'd0)) // s2g dependence satisfy or no dependence
        & ((l2g_dep_queue_V_TVALID_int == 1'b1) | (instruction_l2g_dep_bit == 1'd0)) // l2g dependence satisfy or no dependence
        & (is_load_opcode == 1'd1)
        & (is_acc_memid   == 1'd1)
        & (is_uop_memid == 1'd0)
        & (is_finish_opcode == 1'd0)
        & (1'b1 == is_state_idle))
    begin
        load_acc_x_size <= {{13'b0000000000000}, {load_x_size}, {3'd0}};
    end
end

always @ (*) begin
    if (((icmp_ln89_reg_16475 == 1'd0) & (1'b0 == ap_block_pp2_stage0_11001) & (ap_enable_reg_pp2_iter1 == 1'b1) & (1'b1 == ap_CS_fsm_pp2_stage0))) begin // < x_size, 
        data_port_RREADY = 1'b1;
    end else begin
        data_port_RREADY = 1'b0;
    end
end
// ===========================================================
// Load ACC end
// ===========================================================


// ===========================================================
// Write & Read Acc END
// ===========================================================
compute_acc_mem_V #(
    .DataWidth( 512 ),
    .AddressRange( 2048 ),
    .AddressWidth( 11 ))
acc_mem_V_U(
    .clk(ap_clk),                           // Input
    .reset(ap_rst_n_inv),                   // Input
    .address0(acc_mem_V_address0),          // TODO // Address
    .ce0(acc_mem_V_ce0),                    // TODO
    .we0(acc_mem_V_we0),                    // TODO
    .d0(acc_mem_V_d0),                      // TODO Write Data // gemm or alu
    .q0(acc_mem_V_q0),                      // Gen By Module 
    .address1(acc_mem_V_address1),          // TODO
    .ce1(acc_mem_V_ce1),                    // TODO Enable
    .we1(acc_mem_V_we1),                    // TODO
    .d1(acc_mem_V_d1),                      // TODO Write Data // Load Data to ACC mem
    .q1(acc_mem_V_q1)                       // Gen By Module
);
// ===========================================================
// Write & Read ACC end
// ===========================================================

// ===========================================================
//  Write & Read Acc END
// ===========================================================
compute_uop_mem_V #(
    .DataWidth( 32 ),
    .AddressRange( 8192 ),
    .AddressWidth( 13 ))
uop_mem_V_U(
    .clk(ap_clk),                           // Input
    .reset(ap_rst_n_inv),                   // Input
    .address0(uop_mem_V_address0),          // TODO
    .ce0(uop_mem_V_ce0),                    // TODO
    .we0(uop_mem_V_we0),                    // TODO
    .d0(uop_port_addr_read_reg_16568),      // TODO
    .q0(uop_mem_V_q0)                       // Gen By Module. Uop Data
);


always @ (*) begin
    if (((1'b0 == ap_block_pp3_stage0) & (ap_enable_reg_pp3_iter2 == 1'b1))) begin
        uop_mem_V_address0 = zext_ln480_3_fu_11611_p1;
    end else if (((1'b0 == ap_block_pp1_stage0) & (ap_enable_reg_pp1_iter2 == 1'b1))) begin
        uop_mem_V_address0 = sext_ln265_fu_4847_p1;
    end else if (((1'b0 == ap_block_pp0_stage1) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter0 == 1'b1))) begin
        uop_mem_V_address0 = sext_ln353_fu_2117_p1;
    end else begin
        uop_mem_V_address0 = 'bx;
    end
end

always @ (*) begin
    if ((((1'b0 == ap_block_pp0_stage1_11001) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter0 == 1'b1)) | ((1'b0 == ap_block_pp1_stage0_11001) & (ap_enable_reg_pp1_iter2 == 1'b1)) | ((1'b0 == ap_block_pp3_stage0_11001) & (ap_enable_reg_pp3_iter2 == 1'b1)))) begin
        uop_mem_V_ce0 = 1'b1;
    end else begin
        uop_mem_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln480_reg_16554_pp3_iter1_reg == 1'd0) & (1'b0 == ap_block_pp3_stage0_11001) & (ap_enable_reg_pp3_iter2 == 1'b1))) begin
        uop_mem_V_we0 = 1'b1;
    end else begin
        uop_mem_V_we0 = 1'b0;
    end
end

always @ (posedge ap_clk) begin
    if (((icmp_ln480_reg_16554 == 1'd0) & (1'b0 == ap_block_pp3_stage0_11001) & (1'b1 == ap_CS_fsm_pp3_stage0))) begin
        uop_port_addr_read_reg_16568 <= uop_port_RDATA;
    end
end


always @ (*) begin
    if (((1'b0 == ap_block_pp1_stage0) & (ap_enable_reg_pp1_iter9 == 1'b1))) begin
        acc_mem_V_address0 = acc_mem_V_addr_1_reg_16040_pp1_iter8_reg;
    end else if (((1'b0 == ap_block_pp0_stage0) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_enable_reg_pp0_iter4 == 1'b1))) begin
        acc_mem_V_address0 = acc_mem_V_addr_3_reg_13301_pp0_iter3_reg;
    end else if (((1'b0 == ap_block_pp0_stage1) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter1 == 1'b1))) begin
        acc_mem_V_address0 = zext_ln544_3_fu_2148_p1;
    end else begin
        acc_mem_V_address0 = 'bx;
    end
end

always @ (*) begin
    if ((((1'b0 == ap_block_pp0_stage1_11001) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter1 == 1'b1)) | ((1'b0 == ap_block_pp1_stage0_11001) & (ap_enable_reg_pp1_iter9 == 1'b1)) | ((1'b0 == ap_block_pp0_stage0_11001) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_enable_reg_pp0_iter4 == 1'b1)))) begin
        acc_mem_V_ce0 = 1'b1;
    end else begin
        acc_mem_V_ce0 = 1'b0;
    end
end

always @ (*) begin
    if ((((1'b0 == ap_block_pp1_stage0_11001) & (icmp_ln253_reg_13919_pp1_iter8_reg == 1'd0) & (ap_enable_reg_pp1_iter9 == 1'b1)) | ((1'b0 == ap_block_pp0_stage0_11001) & (icmp_ln343_reg_13229_pp0_iter3_reg == 1'd0) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_enable_reg_pp0_iter4 == 1'b1)))) begin
        acc_mem_V_we0 = 64'd18446744073709551615;
    end else begin
        acc_mem_V_we0 = 64'd0;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp1_stage0) & (ap_enable_reg_pp1_iter9 == 1'b1))) begin
        acc_mem_V_d0 = tmp_8_fu_11274_p17;
    end else if (((1'b0 == ap_block_pp0_stage0) & (1'b1 == ap_CS_fsm_pp0_stage0) & (ap_enable_reg_pp0_iter4 == 1'b1))) begin
        acc_mem_V_d0 = tmp_14_fu_4576_p17;
    end else begin
        acc_mem_V_d0 = 'bx;
    end
end

always @ (*) begin
    if (((1'b0 == ap_block_pp2_stage0) & (ap_enable_reg_pp2_iter3 == 1'b1))) begin
        acc_mem_V_address1 = zext_ln89_1_fu_11540_p1;
    end else if (((1'b0 == ap_block_pp1_stage0) & (ap_enable_reg_pp1_iter7 == 1'b1))) begin
        acc_mem_V_address1 = zext_ln544_2_fu_8779_p1;
    end else if (((1'b0 == ap_block_pp0_stage1) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter1 == 1'b1))) begin
        acc_mem_V_address1 = zext_ln544_4_fu_2152_p1;
    end else begin
        acc_mem_V_address1 = 'bx;
    end
end

always @ (*) begin
    if ((((1'b0 == ap_block_pp0_stage1_11001) & (1'b1 == ap_CS_fsm_pp0_stage1) & (ap_enable_reg_pp0_iter1 == 1'b1)) | ((1'b0 == ap_block_pp1_stage0_11001) & (ap_enable_reg_pp1_iter7 == 1'b1)) | ((1'b0 == ap_block_pp2_stage0_11001) & (ap_enable_reg_pp2_iter3 == 1'b1)))) begin
        acc_mem_V_ce1 = 1'b1;
    end else begin
        acc_mem_V_ce1 = 1'b0;
    end
end

always @ (*) begin
    if (((icmp_ln89_reg_16475_pp2_iter2_reg == 1'd0) & (1'b0 == ap_block_pp2_stage0_11001) & (ap_enable_reg_pp2_iter3 == 1'b1))) begin
        acc_mem_V_we1 = shl_ln89_4_reg_16529;
    end else begin
        acc_mem_V_we1 = 64'd0;
    end
end

assign acc_mem_V_d1 = (select_ln89_3_fu_11553_p3 & and_ln89_reg_16524);
assign select_ln89_3_fu_11553_p3 = ((icmp_ln89_1_reg_16510_pp2_iter2_reg[0:0] === 1'b1) ? tmp_33_fu_11544_p4 : shl_ln89_1_reg_16518);



endmodule //compute
